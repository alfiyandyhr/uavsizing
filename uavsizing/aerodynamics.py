import numpy as np
import openmdao.api as om

class WingedCruiseDrag(om.ExplicitComponent):
	"""
	Computes the drag of a winged configuration in cruise.
	Based on simple polar drag equations.
	Inputs:
		Aero|Lift
		UAV|S_wing
		UAV|Speed
	Outputs:
		Aero|Drag
		Aero|CL_cruise
	"""
	def initialize(self):
		self.options.declare('rho_air', default=1.225, desc='Air density')
		self.options.declare('Cd0', types=float, desc='Minimum Cd of the drag polar')
		self.options.declare('wing_AR', types=float, desc='Wing aspect ratio')
		self.options.declare('wing_e', types=float, desc='Oswald efficiency')

	def setup(self):
		self.add_input('Aero|Lift', units='N', desc='Lift generated by the wing')
		self.add_input('UAV|Speed', units='m/s', desc='Cruise speed')
		self.add_input('UAV|S_wing', units='m**2', desc='Wing reference area')
		self.add_output('Aero|Drag', units='N', desc='Drag of a winged configuration')
		self.add_output('Aero|CL_cruise', desc='Lift coefficient')
		self.declare_partials('*', '*')

		# self.rho_air = 1.225 # air density
		# self.CD0 = 0.01 # zero-lift drag coefficient (of just wing, not including the body)
		# self.wing_AR = 8
		# self.wing_e = 0.8

	def compute(self, inputs, outputs):
		rho_air = self.options['rho_air']
		CD0 = self.options['Cd0']
		wing_AR = self.options['wing_AR']
		wing_e = self.options['wing_e']
		L = inputs['Aero|Lift']
		v = inputs['UAV|Speed']
		S_wing = inputs['UAV|S_wing']

		q = 0.5 * rho_air * v**2 	 					# dynamic pressure
		CL = L/(q * S_wing)								# lift coefficient
		CD = CD0 + CL**2 / (np.pi * wing_e * wing_AR)	# drag coefficient
		outputs['Aero|Drag'] = q * S_wing * CD			# drag
		outputs['Aero|CL_cruise'] = CL

	def compute_partials(self, inputs, partials):
		rho_air = self.options['rho_air']
		CD0 = self.options['Cd0']
		wing_AR = self.options['wing_AR']
		wing_e = self.options['wing_e']
		L = inputs['Aero|Lift']
		v = inputs['UAV|Speed']
		S_wing = inputs['UAV|S_wing']

		q = 0.5 * rho_air * v**2 	 					# dynamic pressure
		CL = L/(q * S_wing)								# lift coefficient
		dq_dv = rho_air * v
		dCL_dL = 1/(q * S_wing)
		dCL_dq = -L/(S_wing * q**2)
		dCL_dS = -L/(q * S_wing**2)
		
		CD = CD0 + CL**2 / (np.pi * wing_e * wing_AR)	# drag coefficient
		dCD_dCL = 2*CL / (np.pi * wing_e * wing_AR)
		dD_dq = S_wing * CD
		dD_dS = q * CD
		dD_dCD = q * S_wing

		partials['Aero|Drag', 'Aero|Lift'] = dD_dCD * dCD_dCL * dCL_dL
		partials['Aero|Drag', 'UAV|S_wing'] = dD_dS + dD_dCD * dCD_dCL * dCL_dS
		partials['Aero|Drag', 'UAV|Speed'] = (dD_dCD*dCD_dCL*dCL_dq + dD_dq) * dq_dv
		partials['Aero|CL_cruise', 'Aero|Lift'] = dCL_dL
		partials['Aero|CL_cruise', 'UAV|S_wing'] = dCL_dS
		partials['Aero|CL_cruise', 'UAV|Speed'] = dCL_dq * dq_dv


class BodyDrag(om.ExplicitComponent):
	"""
	Computes the drag of the body of a multirotor
	Inputs:
		UAV|r_rotor
		UAV|Speed
		Body|sin_beta
	Outputs:
		Aero|Drag
	"""
	def setup(self):
		self.add_input('UAV|r_rotor', units='m', desc='Rotor radius')
		self.add_input('UAV|Speed', units='m/s', desc='Cruise speed')
		self.add_input('Body|sin_beta', desc='sin(beta), beta: incidence angle of body')
		self.add_output('Aero|Drag', units='N', desc='Drag of the body')
		self.declare_partials('*', '*')

		self.rho_air = 1.225 # air density

	def compute(self, inputs, outputs):
		r = inputs['UAV|r_rotor']
		v = inputs['UAV|Speed']
		sin_beta = inputs['Body|sin_beta']

		S_body = 1.682 * r**2 				# body area
		CD_body = 0.1 + 0.2 * sin_beta**3 	# body drag coefficient

		outputs['Aero|Drag'] = 0.5 * self.rho_air * v * v * S_body * CD_body

	def compute_partials(self, inputs, partials):
		r = inputs['UAV|r_rotor']
		v = inputs['UAV|Speed']
		sin_beta = inputs['Body|sin_beta']

		S_body = 1.682 * r**2 				# body area
		dS_dr = 1.682 * 2 * r
		CD_body = 0.1 + 0.2 * sin_beta**3 	# body drag coefficient
		dCD_dsinB = 0.2 * 3 * sin_beta**2

		partials['Aero|Drag', 'UAV|r_rotor'] = 0.5 * self.rho_air * v * v * CD_body * dS_dr
		partials['Aero|Drag', 'UAV|Speed'] = self.rho_air * v * S_body * CD_body
		partials['Aero|Drag', 'Body|sin_beta'] = 0.5 * self.rho_air * v * v * S_body * dCD_dsinB
